class Dispatcher extends Engine.Actor
 implements InterestedInCommandDispatched,
            InterestedInEventBroadcast,
            InterestedInPlayerDisconnected;

/**
 * Length of autogenerated random key assigned to a dispatched command
 */
var config int CommandIdLength;

/**
 * Time in seconds a player is allowed to issue another commandW
 */
var config float CommandThreshold;

/**
 * Time in seconds a command should be failed if not responded within the time
 */
var config float CommandTimeout;


struct sBoundCommand
{
    /**
     * Command name
     */
    var string Name;

    /**
     * Reference to the receiver all commands with this name should be dispatched to
     */
    var InterestedInCommandDispatched Receiver;

    /**
     * Command description (displayed in the !command help text)
     */
    var string Description;

    /**
     * Command usage desription (displayed in the !command help text and )
     */
    var string Usage;

    /**
     * Indicate whether the command arguments contain sensitive data
     * that should not be displayed back to the user
     */
    var bool bSensitive;
};

struct sDispatchedCommand
{
    /**
     * Index of the corresponding bound command
     */
    var int BoundIndex;

    /**
     * Dispatched command unique id
     */
    var string Id;

    /**
     * Time the command was dispatched at (Level.TimeSeconds)
     */
    var float TimeDispatched;

    /**
     * The player that has issued the command
     */
    var Player Player;

    /**
     * Indicate whether the command receiver has replied
     */
    var bool bReplied;
};

var Core Core;

/**
 * List of bound commands
 */
var array<sBoundCommand> BoundCommands;

/**
 * List of dispatched commands
 */
var array<sDispatchedCommand> DispatchedCommands;


public function PreBeginPlay()
{
    Super.PreBeginPlay();
    self.Disable('Tick');
}

/**
 * Clean up obsolete dispatched commands
 */
event Timer()
{
    self.HandleDispatchedCommands();
}

public function Init(Core Core)
{
    self.Core = Core;

    self.Core.RegisterInterestedInPlayerDisconnected(self);
    self.Core.RegisterInterestedInEventBroadcast(self);
    // Register the help command
    self.Bind(
        "help",
        self,
        self.Core.Locale.Translate("DispatcherHelpUsage"),
        self.Core.Locale.Translate("DispatcherHelpDescription")
    );
    // Use fixed tick rate
    self.SetTimer(class'Core'.const.DELTA, true);
}

/**
 * Attempt to parse a command from either Say or TeamSay event message
 */
public function bool OnEventBroadcast(Player Caller, Actor Sender, name Type, string Msg, optional PlayerController Receiver, optional bool bHidden)
{
    local string Name, Message;
    local array<string> Words;

    switch (Type)
    {
        case 'Say' :
        case 'TeamSay' :
            break;
        default :
            return true;
    }

    Message = class'Utils.StringUtils'.static.Filter(Msg);

    if (Mid(Message, 0, 1) == "!" && Mid(Message, 1, 1) != "!")  // Ignore !!+
    {
        if (Caller != None)
        {
            Words = class'Utils.StringUtils'.static.SplitWords(Mid(Message, 1));

            if (Words.Length > 0)
            {
                // The word is translated into a command name
                Name = Words[0];
                // The rest become the command arguments
                Words.Remove(0, 1);
                // Get the caller
                self.Dispatch(Name, Words, Caller);
                // Hide this event from chat
                return false;
            }
        }
    }
    return true;
}

/**
 * Respond to user whenever the help command is issued
 */
public function OnCommandDispatched(Dispatcher Dispatcher, string Name, string Id, array<string> Args, Player Player)
{
    local string Response;

    switch (Name)
    {
        case "help":
            Response = self.Core.Locale.Translate(
                "DispatcherCommandList",
                class'Utils.ArrayUtils'.static.Join(self.GetBoundCommandNames(), ", ")
            );
            break;
        default:
            return;
    }

    self.Respond(Id, Response);
}

/**
 * Remove dispatched commands issued by the disconnected player
 */
public function OnPlayerDisconnected(Player Player)
{
    local int i;

    for (i = self.DispatchedCommands.Length-1; i >= 0 ; i--)
    {
        if (self.DispatchedCommands[i].Player == Player)
        {
            self.DispatchedCommands[i].Player = None;
            self.DispatchedCommands.Remove(i, 1);
        }
    }
}

/**
 * Attempt to bind a command
 *
 * @param   Name
 *          Case-insensitive command name
 * @param   Receiver
 *          A InterestedInCommandDispatched instance the command shoukd be bound with
 * @param   Usage
 *          Command human friendly usage
 * @param   Description
 *          Command description
 * @param   bSensitive (optional)
 *          Indicate whether command arguments should not be displayed back to user
 */
public function Bind(string Name, InterestedInCommandDispatched Receiver, string Usage, string Description, optional bool bSensitive)
{
    local sBoundCommand Command;

    Name = Lower(class'Utils.StringUtils'.static.Strip(class'Utils.StringUtils'.static.DropSpace(Name)));

    // Dont allow whitespace in a command name
    if (Name == "")
    {
        log(self $ ": wont register an empty command");
        return;
    }

    // Dont allow duplicate command entries
    if (class'Utils.ArrayUtils'.static.Search(self.GetBoundCommandNames(), Name) >= 0)
    {
        log(self $ ": " $ Name $ " has already been bound");
        return;
    }

    Command.Name = Name;
    Command.Description = Description;
    Command.Usage = Usage;
    Command.bSensitive = bSensitive;
    Command.Receiver = Receiver;

    self.BoundCommands[self.BoundCommands.Length] = Command;

    log(self $ ": successfully registered " $ Name $ " (" $ Receiver $ ")");
}

/**
 * Attempt to unbind a command
 */
public function Unbind(string Name, InterestedInCommandDispatched Receiver)
{
    local int i;

    for (i = self.BoundCommands.Length-1; i >= 0; i--)
    {
        if (self.BoundCommands[i].Name ~= Name && self.BoundCommands[i].Receiver == Receiver)
        {
            log(self $ ": unregistering " $ self.BoundCommands[i].Name $ " (" $ Receiver $ ")");
            self.BoundCommands[i].Receiver = None;
            self.BoundCommands.Remove(i, 1);
            return;
        }
    }
}

/**
 * Unbind all commands that have been bound with specific Receiver
 */
public function UnbindAll(InterestedInCommandDispatched Receiver)
{
    local int i;

    for (i = self.BoundCommands.Length-1; i >= 0; i--)
    {
        if (self.BoundCommands[i].Receiver == Receiver)
        {
            log(self $ ": unregistering " $ self.BoundCommands[i].Name $ " (" $ Receiver $ ")");
            self.BoundCommands[i].Receiver = None;
            self.BoundCommands.Remove(i, 1);
        }
    }
}

public function ThrowError(string CommandId, string Error)
{
    local int i;
    local sBoundCommand Command;

    i = self.GetDispatchedCommandById(CommandId);

    if (i == -1)
    {
        return;
    }

    Command = self.BoundCommands[self.DispatchedCommands[i].BoundIndex];

    self.PrintText(class'Utils.StringUtils'.static.Format(Error, Command.Name), self.DispatchedCommands[i].Player);

    self.DispatchedCommands[i].bReplied = true;
}

public function ThrowUsageError(string CommandId)
{
    self.ThrowError(CommandId, self.Core.Locale.Translate("DispatcherUsageError"));
}

public function ThrowPermissionError(string CommandId)
{
    self.ThrowError(CommandId, self.Core.Locale.Translate("DispatcherPermissionError"));
}

/**
 * Display command successful response
 */
public function Respond(string CommandId, string Response)
{
    local int i;

    i = self.GetDispatchedCommandById(CommandId);

    if (i == -1 || self.DispatchedCommands[i].bReplied)
    {
        return;
    }

    self.PrintText(Response, self.DispatchedCommands[i].Player);
    self.DispatchedCommands[i].bReplied = true;
}

/**
 * Abort a command
 */
public function Void(string CommandId)
{
    local int i;

    i = self.GetDispatchedCommandById(CommandId);

    if (i == -1 || self.DispatchedCommands[i].bReplied)
    {
        return;
    }

    self.DispatchedCommands[i].bReplied = true;
}

/**
 * Attempt to dispatch a player command
 */
protected function Dispatch(string CommandName, array<string> Args, Player Player)
{
    local int i;

    if (Player == None)
    {
        return;
    }

    if (!self.IsAllowedToIssueCommands(Player))
    {
        self.PrintText(self.Core.Locale.Translate("DispatcherCommandCooldown"), Player);
        return;
    }

    i = self.GetBoundCommandByName(CommandName);

    if (i == -1)
    {
        self.PrintText(self.Core.Locale.Translate("DispatcherCommandInvalid", CommandName), Player);
        return;
    }

    // Command header
    self.PrintHeader(CommandName, Args, self.BoundCommands[i].bSensitive, Player);
    // Display help menu instead
    if (Args.Length > 0 && Args[0] ~= "help")
    {
        self.PrintHelp(self.BoundCommands[i].Name, self.BoundCommands[i].Usage, self.BoundCommands[i].Description, Player);
    }
    else
    {
        log(self $ ": dispatching " $ CommandName $ " from " $ Player.GetName() $ " to " $ self.BoundCommands[i].Receiver);

        self.BoundCommands[i].Receiver.OnCommandDispatched(
            self,
            Lower(CommandName),
            self.QueueDispatchedCommand(i, Player),
            Args,
            Player
        );
    }
}

/**
 * Return an array of bound command names
 */
protected function array<string> GetBoundCommandNames()
{
    local int i;
    local array<string> Names;

    for (i = 0; i < self.BoundCommands.Length; i++)
    {
        Names[Names.Length] = self.BoundCommands[i].Name;
    }

    return Names;
}

/**
 * Return index of the bound command matching the given name
 */
protected function int GetBoundCommandByName(string Name)
{
    local int i;

    for (i = 0; i < self.BoundCommands.Length; i++)
    {
        if (self.BoundCommands[i].Name ~= Name)
        {
            return i;
        }
    }

    return -1;
}

/**
 * Return index of the dispatched command matching the given id
 */
protected function int GetDispatchedCommandById(string CommandId)
{
    local int i;

    for (i = 0; i < self.DispatchedCommands.Length; i++)
    {
        if (self.DispatchedCommands[i].Id == CommandId)
        {
            return i;
        }
    }

    return -1;
}

/**
 * Attempt to remove timed out commands and display appropriate output
 */
protected function HandleDispatchedCommands()
{
    local int i;

    for (i = self.DispatchedCommands.Length-1; i >= 0; i--)
    {
        if (!self.DispatchedCommands[i].bReplied)
        {
            // Command has timed out
            if (self.DispatchedCommands[i].TimeDispatched + self.CommandTimeout < Level.TimeSeconds)
            {
                self.PrintText(self.Core.Locale.Translate("DispatcherCommandTimedout"), self.DispatchedCommands[i].Player);
                self.DispatchedCommands[i].bReplied = true;
            }
        }
        else if (self.DispatchedCommands[i].TimeDispatched + self.CommandThreshold < Level.TimeSeconds)
        {
            self.DispatchedCommands.Remove(i, 1);
        }
    }
}

/**
 * Tell whether the given player is allowed to issue commands
 */
protected function bool IsAllowedToIssueCommands(Player Player)
{
    local int i;

    for (i = self.DispatchedCommands.Length-1; i >= 0 ; i--)
    {
        if (self.DispatchedCommands[i].Player == Player)
        {
            return false;
        }
    }
    return true;
}

/**
 * Queue a new dispatched command. Return the command unique id.
 *
 * @param   BoundIndex
 *          BoundCommands array index of the bound command
 * @param   Player
 *          The caller
 */
protected function string QueueDispatchedCommand(int BoundIndex, Player Player)
{
    local sDispatchedCommand Dispatched;

    // Generate a random id
    Dispatched.Id = class'Utils.StringUtils'.static.Random(self.CommandIdLength, ":alpha:");

    Dispatched.BoundIndex = BoundIndex;
    Dispatched.Player = Player;
    Dispatched.TimeDispatched = Level.TimeSeconds;

    self.DispatchedCommands[self.DispatchedCommands.Length] = Dispatched;

    return Dispatched.Id;
}

/**
 * Format command output
 *
 * @param   Text
 *          Unformatted text
 * @param   Player
 *          Receiver
 */
protected function PrintText(string Text, Player Player)
{
    local int i;
    local array<string> Lines;

    // Split text in lines
    Lines = class'Utils.StringUtils'.static.Part(class'Utils.StringUtils'.static.NormNewline(Text), "\n");

    for (i = 0; i < Lines.Length; i++)
    {
        class'Utils.LevelUtils'.static.TellPlayer(
            self.Level,
            self.Core.Locale.Translate("DispatcherOutputLine", Lines[i]),
            Player.PC,
            self.Core.Locale.Translate("DispatcherOutputColor")
        );
    }
}

/**
 * Print command help
 */
protected function PrintHelp(string Name, string Usage, string Description, Player Player)
{
    self.PrintText(
        self.Core.Locale.Translate(
            "DispatcherCommandHelp",
            Description,
            class'Utils.StringUtils'.static.Format(Usage, Name)
        ),
        Player
    );
}

/**
 * Print command header
 */
protected function PrintHeader(string Name, array<string> Args, bool bSensitive, Player Player)
{
    // Hide arguments from output
    if (Args.Length > 0 && bSensitive)
    {
        Args.Remove(0, Args.Length);
    }
    self.PrintText(
        class'Utils.StringUtils'.static.RStrip(
            self.Core.Locale.Translate("DispatcherOutputHeader", Name, class'Utils.ArrayUtils'.static.Join(Args, " ") $ " ")
        ),
        Player
    );
}

event Destroyed()
{
    self.Core.UnregisterInterestedInEventBroadcast(self);
    self.Core.UnregisterInterestedInPlayerDisconnected(self);

    while (self.DispatchedCommands.Length > 0)
    {
        self.DispatchedCommands[0].Player = None;
        self.DispatchedCommands.Remove(0, 1);
    }

    while (self.BoundCommands.Length > 0)
    {
        self.BoundCommands[0].Receiver = None;
        self.BoundCommands.Remove(0, 1);
    }

    self.Core = None;

    Super.Destroyed();
}

defaultproperties
{
    CommandIdLength=8;
    CommandThreshold=3.0;
    CommandTimeout=3.0;
}
